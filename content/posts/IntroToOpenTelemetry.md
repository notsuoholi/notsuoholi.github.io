+++
title = 'Instrumentation with OpenTelemetry'
date = 2024-10-27
draft = false
+++
## OpenTelemetry - An Overview
OTEL is an open source observability framework. It offers vendor-agnostic or vendor-neutral APIs, software development kits (SDKs) and other tools for collecting telemetry data from cloud-native applications and their supporting infrastructure to understand their performance and health.

It standardizes the way telemetry data is collected and transmitted to our backend platforms. With a common format for instrumentation used across our services, we avoid gaps in visibility.

Development teams do not need to re-instrument code when something changes, it evolves as the application does.

OTEL allows us to instrument the individual parts of our application like fetch requests, db drivers, various paths each service, etc. Instrumenting these pieces allows us to measure which parts of our application are performant and which are not.

### OTLP - Open Telemetry Protocol
Defines the common props/fields within the message we are sending to the OTEL collector which then ends up in our observability backends.

It is a protobuf schema which can be sent over gRPC (most common) or HTTP.

**<sub>Note: A Protocol Buffers (protobuf) schema defines the structure of data used in communication between applications or services.</sub>**

### OTEL Collector
A service which operates as a collector for the data which is generated by the applications/services which you are interested in measuring. It is the thing which sits between your services and your observability backends (Prometheus, Tempo, Loki, etc.).

It is particularly useful for the following reasons:
- Aggregating data
- Scrubbing personally identifiable information before ingestion into long storage
- Batch requests to third party services to prevent rate limiting

### Instrumentation
Auto-Instrumentation (No Code Solution)
- Allows you to instrument your applications without altering source code. It gives you visibility into your service without having to use the OTEL API & SDK code-based instrumentation.
- Uses an agent or agent-like installation. It injects calls to the OTEL API and SDK into the application via various mechanisms based on language.
- Best used when you want to instrument the libraries you're using within your application. Things like requests and responses, database calls, message q
- To get started with auto-implementation you need to run with a supported language and service name configured so your observability backend can identify the service.
- More on Auto-Instrumentation can be found [here](https://opentelemetry.io/docs/concepts/instrumentation/zero-code/).

Custom Instrumentation
- If you have some unique application code you want to measure, you will need to instrument that via code.
    - Say you have a part of code which parses a `.csv` file and you want visibility into that process, you may find creating a custom span helps you track the performance of that particular process.
- Learn more [here](https://opentelemetry.io/docs/concepts/instrumentation/code-based/).

Library Instrumentation
- Helpful when you want to instrument a specific piece of your service with a library.
    - i.e. If you have a DB driver, like the `JDBC-ODBC` or `MongoDB` driver and you want to measure its performance without having to instrument it yourself.
- Learn more [here](https://opentelemetry.io/docs/concepts/instrumentation/libraries/).

### Setting Up Your Collector
The collector comes in various formats but since we're thinking about observing a system comprised of connected microservices, we'd likely run it in a container in our Kubernetes cluster.

There are five integral pieces we must configure for our collector which are:

- Receivers
    - How the collector takes in data from your application.
    - We determine which ports the collector listen on and configure our application to send data to those ports. This is useful as we can define which protocol to associate with a specific port (80, 443, etc.).
- Processors
    - Transforms messages from collector before they are sent to the exporter for transmission to the observability backend.
    - Here we can do things like filter out data, scrub sensitive data, combine like data, etc.
- Extensions
    - Here we can define additional behavior for the collector.
    - We could have an extension which monitors the health of the collector, service monitoring, data forwarding, etc.
- Exporters
    - Where we define how the collector sends things through the pipeline to the backend(s).
    - We define exporters for different backends.
        - Loki, Prometheus, Jaeger, Mimir, etc.
    - Debug exporters are useful for understanding the data you're trying to collect and whether it is in the form you expect.
- Pipelines
    - All of these things combined are what the pipeline is composed of.
- Connectors
    -  A combination of pipelines which are processed together for compose-ability.
    - The connector consumes data as an exporter at the end of one pipeline and emits data as a receiver at the beginning of another. The data could be of the same or different types.

### [Next Article...(Intro to Monitoring and Observability)](IntroToMonitoringAndObservability)

## Sources
[What is OpenTelemetry](https://opentelemetry.io/docs/what-is-opentelemetry/)